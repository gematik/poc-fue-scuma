= SCUMA - Smart Contract based User Managed Access
:toc:
:icons: font
:source-highlighter: rouge

This concept defines a smart contract which allows the owner of a resource to grant access to resources he owns to particular users.

== Definitions

=== EOA - external owned account

In general, there are two types of accounts: externally owned accounts, controlled by private keys, and contract accounts, controlled by their contract code. See https://ethereum.org/en/whitepaper/#ethereum-accounts[Ethereum Accounts].

=== Resource - web resource

A resource is available via the internet and can be localized and access by an Uniform Resource Locator (URL).

=== Resource Provider
The resource provider holds resources and provides interfaces to access them.

=== ProtectionAuthorizationId
The ProtectionAuthorizationId is the 20 byte address of an EOA controlled by the provider. The owner authorizes the controller of this Id to use a smart contract to protect his resources.

=== User
The user accesses resources by using the interfaces provided by the resource provider.

=== UserId
The UserId uniquely identifies the user. It is the 20 byte address of an EOA controlled by the user.

=== Owner
The owner is a special user which owns resources. The ownership of resources is defined by the content of resources. The resources owned by the owner contain the UserId of the owner.

=== Smart contract
Smart contracts digitize agreements by turning the terms of an agreement into computer code that automatically executes when the contract terms are met. They are stored on a blockchain, addressed by a contract account, behave exactly as programmed and cannot be changed. See https://ethereum.org/en/smart-contracts[Smart Contracts].

=== ContractId
The ContractId is the 20 byte address of a contract account. See https://ethereum.org/en/whitepaper/#ethereum-accounts[Ethereum Accounts].



== Use Cases

=== Protect resource
Resources are protected by a default deny policy. In order to enable the resource owner to define access policies the resource needs to be registered at the smart contract by the resource provider. Beforehand, the resource provider needs the entitlement of the resource owner to protect the resource on his behalf.

[plantuml]
.sequenz diagram protect resource
----
@startuml

title Protect Resource

participant "Resource Provider" as PROVIDER
participant "SCUMA" as SC
participant "Owner" as OWNER

activate PROVIDER
PROVIDER <-- OWNER : GET Resource(ResourceURL, OwnerId)
PROVIDER --> OWNER : 401: WWW-authenticate = Challenge
PROVIDER <-- OWNER : GET Resource(ResourceURL, OwnerId), Authorization = Credential
PROVIDER --> OWNER : Resource
deactivate PROVIDER
PROVIDER <-- OWNER : ProtectResource(ResourceURL, OwnerId)
activate PROVIDER
opt Protection Authorization not yet available
PROVIDER -> PROVIDER : Generate ProtectAuthorizationId
PROVIDER --> OWNER : RequestProtectionAuthoriazion(ProtectionAuthorizationId)
activate OWNER
SC <- OWNER : RegisterProvider(ProtectionAuthorizationId) : Boolean
PROVIDER <-- OWNER : ContractId
deactivate OWNER
PROVIDER -> PROVIDER : Store Mapping Owner -> ContractId, ProtectionAuthorizationId
end
PROVIDER --> SC : RegisterResource(ProtectionAuthorizationId, ProtectedResourceId)
activate SC
SC->SC : CheckProtectionAuthorization : Boolean
SC->SC : RegisterId : Boolean
PROVIDER <-- SC : Success
deactivate SC
PROVIDER -> PROVIDER : Store Mapping ResourceURL -> ProtectedResourceId
PROVIDER --> OWNER : ProtectedResourceId
deactivate PROVIDER
SC <- OWNER : SetPolicy(Policy(ProtectedResourceId, UserID, Method), OwnerId) : Boolean
@enduml
----

=== Access resource
The user access the resource via the interfaces provided by the resource provider using his EOA. The provider maps the resource request onto the protected resources and asks the smart contract for permissions. The smart contract returns the permissions which then are enforced by the provider.

[plantuml]
.sequenz diagram access resource
----
@startuml

title Access Resource

participant "User" as USER
participant "Resource Provider" as PROVIDER
participant "SCUMA" as SC

activate PROVIDER
USER --> PROVIDER : GET Resource(ResourceURL, UserId)
PROVIDER -> PROVIDER : Maps resource request onto ProtectedResourceIds
USER <- PROVIDER : Authenticate(Challenge) : SignedChallenge
activate SC
PROVIDER --> SC : RequestsPermissions((ProtectionAuthorizationId,\n listOf(PermissionRequest(ProtectedResourceID,\n Method)), userId)
SC->SC : CheckProtectionAuthorization(ProtectionAuthorizationId) : Boolean
SC->SC : CheckPolicies(listOf(PermissionRequest(ProtectedResourceID, Method)),\n userId) : listOf(Permission(ProtectedResourceID, Method))
PROVIDER <-- SC : listOf(Permission(ProtectedResourceID, Method))
deactivate SC
PROVIDER->PROVIDER : EnforcePermissions
USER <-- PROVIDER : Resources

@enduml
----

== Smart contract

[source,solidity]
----
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ScumaContract {

    address public Owner;

    address[] public protectionAuthorizationIds;
    mapping(address => uint) public protectionAuthorizationIdIndices;
    Policy[] public policies;
    Rule[][] public ruleLists;
    mapping(uint256 => uint) public policyIndices; // protectedResourceId to policy index

    struct Policy {
        uint256 what;  // protected resource id
        Rule[] ruleList;
    }

    struct Rule {
        address who;  // userId
        AccessMethod how;
    }

    enum AccessMethod {Create, Read, Update, Delete}

    struct Permission {
        uint32 protectedResourceId;
        AccessMethod grantedMethod;
    }

    struct PermissionRequest {
        uint32 protectedResourceId;
        AccessMethod requestedMethod;
    }

    modifier onlyOwner();

    modifier onlyAuthorizedProviders();

    function RegisterProvider(address protectionAuthorizationId) public onlyOwner;

    function UnregisterProvider(address protectionAuthorizationId) public onlyOwner;

    function UnregisterAllProviders() public onlyOwner;

    function registerResource(uint32 protectedResourceId) public onlyAuthorizedProviders;

    function unregisterResource(uint32 protectedResourceId) public onlyAuthorizedProviders;

    function UnregisterAllResources() public onlyAuthorizedProviders;

    function setRule(uint256 protectedResourceId, address userId, AccessMethod method) public onlyOwner;

    function deleteRule(uint256 protectedResourceId, uint index) public onlyOwner;

    function requestPermissions(address userId, PermissionRequest[] calldata permissionRequests) view external returns (Permission[] memory) onlyAuthorizedProviders;
}
----

== TODO's

* DID instead of EOA
* attribute based access control or groups (e.g. merkle proofs ...)
* privacy aware policies


